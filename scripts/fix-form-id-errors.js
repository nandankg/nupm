#!/usr/bin/env node

/**
 * Fix Form ID Generation Errors - Batch Script
 * 
 * PROBLEM SOLVED: Remove client-side generated IDs that cause database errors
 * ERROR: SQLSTATE[42S22]: Column not found: 1054 Unknown column 'S_No'
 * 
 * SOLUTION: Remove S_No, form_id, id, record_id from form submissions
 * Let database auto-generate unique identifiers
 */

const fs = require('fs');
const path = require('path');

// Configuration
const SIGNALLING_FORMS_DIR = './src/departments/signalling/forms';
const BACKUP_DIR = './backups/form-id-fixes';

console.log('üîß Starting Form ID Error Fixes...\n');

// Create backup directory
if (!fs.existsSync(BACKUP_DIR)) {
  fs.mkdirSync(BACKUP_DIR, { recursive: true });
}

// Patterns that cause database errors
const PROBLEMATIC_PATTERNS = {
  // Client-side ID fields that should NOT be sent to API
  CLIENT_SIDE_IDS: [
    /S_No:\s*[^,]+,?\s*/g,
    /form_id:\s*[^,]+,?\s*/g, 
    /id:\s*[^,]+,?\s*/g,
    /record_id:\s*[^,]+,?\s*/g,
    /recordId:\s*[^,]+,?\s*/g,
    /serialNumber:\s*[^,]+,?\s*/g,
    /recordNumber:\s*[^,]+,?\s*/g,
  ],
  
  // State variables for client-side IDs
  CLIENT_STATE_VARS: [
    /const \[sNo,\s*setSNo\]\s*=\s*useState\([^)]+\);?\s*/g,
    /const \[formId,\s*setFormId\]\s*=\s*useState\([^)]+\);?\s*/g,
    /const \[recordId,\s*setRecordId\]\s*=\s*useState\([^)]+\);?\s*/g,
    /const \[serialNumber,\s*setSerialNumber\]\s*=\s*useState\([^)]+\);?\s*/g,
  ],

  // Form fields displaying client-side IDs
  CLIENT_FORM_FIELDS: [
    /<UniversalSignallingFormField[^>]*name="S_No"[^>]*>[\s\S]*?<\/UniversalSignallingFormField>/g,
    /<UniversalSignallingFormField[^>]*name="form_id"[^>]*>[\s\S]*?<\/UniversalSignallingFormField>/g,
    /<UniversalSignallingFormField[^>]*name="record_id"[^>]*>[\s\S]*?<\/UniversalSignallingFormField>/g,
  ],

  // Initial values with client-side IDs
  INITIAL_VALUES_IDS: [
    /S_No:\s*"[^"]*",?\s*/g,
    /form_id:\s*"[^"]*",?\s*/g,
    /id:\s*"[^"]*",?\s*/g,
    /record_id:\s*"[^"]*",?\s*/g,
  ]
};

// Get all signalling form files
const getAllFormFiles = (dir) => {
  const files = [];
  const items = fs.readdirSync(dir);
  
  for (const item of items) {
    const itemPath = path.join(dir, item);
    if (fs.statSync(itemPath).isFile() && item.endsWith('.jsx')) {
      files.push(itemPath);
    }
  }
  
  return files;
};

// Check if file contains problematic patterns
const hasProblematicPatterns = (content) => {
  const patterns = [
    ...PROBLEMATIC_PATTERNS.CLIENT_SIDE_IDS,
    ...PROBLEMATIC_PATTERNS.CLIENT_STATE_VARS,
    ...PROBLEMATIC_PATTERNS.CLIENT_FORM_FIELDS,
    ...PROBLEMATIC_PATTERNS.INITIAL_VALUES_IDS
  ];
  
  return patterns.some(pattern => pattern.test(content));
};

// Fix client-side ID patterns
const fixFormIdPatterns = (content, fileName) => {
  let fixedContent = content;
  let changes = [];

  // 1. Remove client-side IDs from submission data
  PROBLEMATIC_PATTERNS.CLIENT_SIDE_IDS.forEach((pattern, index) => {
    if (pattern.test(fixedContent)) {
      const before = fixedContent.match(pattern)?.[0] || '';
      fixedContent = fixedContent.replace(pattern, '');
      changes.push(`Removed client-side ID field: ${before.trim()}`);
    }
  });

  // 2. Remove client-side state variables  
  PROBLEMATIC_PATTERNS.CLIENT_STATE_VARS.forEach((pattern, index) => {
    if (pattern.test(fixedContent)) {
      const before = fixedContent.match(pattern)?.[0] || '';
      fixedContent = fixedContent.replace(pattern, '');
      changes.push(`Removed client-side state variable: ${before.trim().substring(0, 50)}...`);
    }
  });

  // 3. Remove or comment out client-side form fields
  PROBLEMATIC_PATTERNS.CLIENT_FORM_FIELDS.forEach((pattern, index) => {
    if (pattern.test(fixedContent)) {
      const fieldMatch = fixedContent.match(pattern)?.[0] || '';
      const replacement = `{/* FIXED: Removed client-side ID field - database auto-generates unique IDs */}`;
      fixedContent = fixedContent.replace(pattern, replacement);
      changes.push(`Removed client-side form field display`);
    }
  });

  // 4. Remove client-side IDs from initial values
  PROBLEMATIC_PATTERNS.INITIAL_VALUES_IDS.forEach((pattern, index) => {
    if (pattern.test(fixedContent)) {
      const before = fixedContent.match(pattern)?.[0] || '';
      fixedContent = fixedContent.replace(pattern, '');
      changes.push(`Removed client-side ID from initial values: ${before.trim()}`);
    }
  });

  // 5. Add comment about form_id auto-generation
  if (changes.length > 0) {
    const submissionDataRegex = /(const submissionData = \{)/;
    if (submissionDataRegex.test(fixedContent)) {
      fixedContent = fixedContent.replace(
        submissionDataRegex,
        `$1\n        // FIXED: Remove client-side IDs - form_id is auto-generated by database`
      );
    }
  }

  // 6. Clean up extra commas and spacing
  fixedContent = fixedContent
    .replace(/,\s*,/g, ',')                    // Remove double commas
    .replace(/\{\s*,/g, '{')                   // Remove leading comma in objects
    .replace(/,\s*\}/g, '\n      }')           // Remove trailing comma before closing brace
    .replace(/\n\s*\n\s*\n/g, '\n\n');        // Remove extra blank lines

  return { content: fixedContent, changes };
};

// Create backup of original file
const createBackup = (filePath, content) => {
  const fileName = path.basename(filePath);
  const backupPath = path.join(BACKUP_DIR, `${fileName}.backup`);
  fs.writeFileSync(backupPath, content, 'utf8');
  return backupPath;
};

// Process individual form file
const processFormFile = (filePath) => {
  console.log(`\nüìù Processing: ${path.basename(filePath)}`);
  
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    
    // Check if file needs fixing
    if (!hasProblematicPatterns(content)) {
      console.log('   ‚úÖ No form ID issues found - skipping');
      return { processed: false, changes: [] };
    }

    // Create backup
    const backupPath = createBackup(filePath, content);
    console.log(`   üíæ Backup created: ${backupPath}`);

    // Apply fixes
    const { content: fixedContent, changes } = fixFormIdPatterns(content, path.basename(filePath));

    // Write fixed content
    fs.writeFileSync(filePath, fixedContent, 'utf8');

    console.log('   üîß Applied fixes:');
    changes.forEach(change => console.log(`      ‚Ä¢ ${change}`));

    return { processed: true, changes };

  } catch (error) {
    console.error(`   ‚ùå Error processing ${filePath}:`, error.message);
    return { processed: false, changes: [], error: error.message };
  }
};

// Main execution
const main = async () => {
  try {
    // Get all form files
    const formFiles = getAllFormFiles(SIGNALLING_FORMS_DIR);
    console.log(`üìã Found ${formFiles.length} signalling form files to check\n`);

    const results = {
      total: formFiles.length,
      processed: 0,
      skipped: 0,
      errors: 0,
      totalChanges: 0,
      fileResults: []
    };

    // Process each file
    for (const filePath of formFiles) {
      const result = processFormFile(filePath);
      
      if (result.error) {
        results.errors++;
      } else if (result.processed) {
        results.processed++;
        results.totalChanges += result.changes.length;
      } else {
        results.skipped++;
      }

      results.fileResults.push({
        file: path.basename(filePath),
        ...result
      });
    }

    // Generate summary report
    console.log('\n' + '='.repeat(60));
    console.log('üéâ FORM ID ERROR FIXES COMPLETED');
    console.log('='.repeat(60));
    console.log(`üìä SUMMARY:`);
    console.log(`   Total Files: ${results.total}`);
    console.log(`   Fixed: ${results.processed}`);
    console.log(`   Skipped: ${results.skipped}`);  
    console.log(`   Errors: ${results.errors}`);
    console.log(`   Total Changes: ${results.totalChanges}`);

    if (results.processed > 0) {
      console.log('\n‚úÖ FIXES APPLIED:');
      console.log('   ‚Ä¢ Removed client-side ID fields (S_No, form_id, etc.)');
      console.log('   ‚Ä¢ Cleaned up submission data objects');
      console.log('   ‚Ä¢ Removed problematic form field displays');
      console.log('   ‚Ä¢ Fixed initial values objects');
      console.log('   ‚Ä¢ Added explanatory comments');
      
      console.log('\nüóÑÔ∏è DATABASE BENEFITS:');
      console.log('   ‚Ä¢ form_id now properly auto-generated');
      console.log('   ‚Ä¢ No more "Column not found" errors');
      console.log('   ‚Ä¢ 100% API compatibility');
      console.log('   ‚Ä¢ Consistent unique identifier generation');
    }

    if (results.errors > 0) {
      console.log(`\n‚ö†Ô∏è  ${results.errors} files had errors - check logs above`);
    }

    // Create detailed report file
    const reportPath = path.join(BACKUP_DIR, 'form-id-fixes-report.json');
    fs.writeFileSync(reportPath, JSON.stringify(results, null, 2));
    console.log(`\nüìÑ Detailed report saved: ${reportPath}`);

    console.log('\nüéØ NEXT STEPS:');
    console.log('   1. Test form submissions in development');
    console.log('   2. Verify no database column errors');
    console.log('   3. Confirm form_id auto-generation working');
    console.log('   4. Deploy fixes to production');

  } catch (error) {
    console.error('‚ùå Script execution failed:', error.message);
    process.exit(1);
  }
};

// Execute the script
if (require.main === module) {
  main();
}

module.exports = { fixFormIdPatterns, hasProblematicPatterns };